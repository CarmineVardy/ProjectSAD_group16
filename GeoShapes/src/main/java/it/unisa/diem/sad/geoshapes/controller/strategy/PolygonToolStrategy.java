package it.unisa.diem.sad.geoshapes.controller.strategy;

import it.unisa.diem.sad.geoshapes.controller.InteractionCallback;
import it.unisa.diem.sad.geoshapes.controller.decorator.PreviewShapeDecorator;
import it.unisa.diem.sad.geoshapes.controller.decorator.ShapeDecorator;
import javafx.geometry.Point2D;
import javafx.scene.Cursor;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Implements the {@link ToolStrategy} for drawing polygons.
 * This strategy supports both regular and irregular polygon creation.
 * For regular polygons, it handles two clicks (center and radius/side point).
 * For irregular polygons, it allows clicking multiple vertices and finalizing the polygon
 * by clicking near the first vertex or when the maximum number of vertices is reached.
 */
public class PolygonToolStrategy implements ToolStrategy {

    // Public static final constants
    private static final double POINT_RADIUS = 3.0;
    private static final double MIN_SIDE_LENGTH = 10.0;

    // Private instance variables
    private final Pane drawingArea;
    private final InteractionCallback callback;

    private Color borderColor;
    private Color fillColor;
    private int polygonVertices;
    private boolean regularPolygon;

    private Point2D firstPoint;
    private Point2D secondPoint;
    private Circle firstPointPreview;
    private ShapeDecorator firstPointDecorator;

    // For irregular polygons
    private List<Point2D> vertices;
    private List<Circle> vertexPreviews;
    private List<Line> edgePreviews;
    private List<ShapeDecorator> previewDecorators;

    /**
     * Constructs a new {@code PolygonToolStrategy}.
     *
     * @param drawingArea The {@link Pane} where shapes will be drawn.
     * @param callback The {@link InteractionCallback} to notify about shape creation.
     */
    public PolygonToolStrategy(Pane drawingArea, InteractionCallback callback) {
        this.drawingArea = drawingArea;
        this.callback = callback;
        this.vertices = new ArrayList<>();
        this.vertexPreviews = new ArrayList<>();
        this.edgePreviews = new ArrayList<>();
        this.previewDecorators = new ArrayList<>();
    }

    /**
     * Activates the polygon tool, setting its initial border and fill colors,
     * number of vertices, and regular polygon mode.
     *
     * @param lineBorderColor The current border color for lines (ignored).
     * @param rectangleBorderColor The current border color for rectangles (ignored).
     * @param rectangleFillColor The current fill color for rectangles (ignored).
     * @param ellipseBorderColor The current border color for ellipses (ignored).
     * @param ellipseFillColor The current fill color for ellipses (ignored).
     * @param polygonBorderColor The current border color for polygons.
     * @param polygonFillColor The current fill color for polygons.
     * @param textBorderColor The current border color for text shapes (ignored).
     * @param textFillColor The current fill color for text shapes (ignored).
     * @param textColor The current text color for text shapes (ignored).
     * @param polygonVertices The number of vertices for polygons.
     * @param regularPolygon A boolean indicating if the polygon should be regular.
     * @param fontSize The font size for text shapes (ignored).
     */
    @Override
    public void activate(Color lineBorderColor, Color rectangleBorderColor, Color rectangleFillColor, Color ellipseBorderColor, Color ellipseFillColor, Color polygonBorderColor, Color polygonFillColor, Color textBorderColor, Color textFillColor, Color textColor, int polygonVertices, boolean regularPolygon, int fontSize) {
        this.borderColor = polygonBorderColor;
        this.fillColor = polygonFillColor;
        this.polygonVertices = polygonVertices;
        this.regularPolygon = regularPolygon;
    }

    /**
     * Handles the mouse pressed event.
     * Depending on whether regular or irregular polygon mode is active,
     * it either captures points for a regular polygon or adds vertices for an irregular one.
     *
     * @param event The {@link MouseEvent} generated by the mouse press.
     */
    @Override
    public void handleMousePressed(MouseEvent event) {
        drawingArea.setCursor(Cursor.CROSSHAIR); // Change cursor to crosshair
        Point2D localPoint = drawingArea.sceneToLocal(event.getSceneX(), event.getSceneY());

        if (regularPolygon) {
            handleRegularPolygonClick(localPoint);
        } else {
            handleIrregularPolygonClick(localPoint);
        }
    }

    /**
     * Handles the mouse dragged event.
     * This implementation does nothing.
     *
     * @param event The {@link MouseEvent} generated by the mouse drag.
     */
    @Override
    public void handleMouseDragged(MouseEvent event) {
        // No specific action on mouse dragged for this tool
    }

    /**
     * Handles the mouse released event.
     * Restores the default cursor.
     *
     * @param event The {@link MouseEvent} generated by the mouse release.
     */
    @Override
    public void handleMouseReleased(MouseEvent event) {
        drawingArea.setCursor(Cursor.DEFAULT); // Restore default cursor
    }

    /**
     * Handles the mouse moved event.
     * This implementation does nothing.
     *
     * @param event The {@link MouseEvent} generated by the mouse movement.
     */
    @Override
    public void handleMouseMoved(MouseEvent event) {
        // No specific action on mouse moved for this tool
    }

    /**
     * Handles a change in the line border color property (ignored by this strategy).
     *
     * @param color The new {@link Color} for the line border.
     */
    @Override
    public void handleLineBorderColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a change in the rectangle border color property (ignored by this strategy).
     *
     * @param color The new {@link Color} for the rectangle border.
     */
    @Override
    public void handleRectangleBorderColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a change in the rectangle fill color property (ignored by this strategy).
     *
     * @param color The new {@link Color} for the rectangle fill.
     */
    @Override
    public void handleRectangleFillColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a change in the ellipse border color property (ignored by this strategy).
     *
     * @param color The new {@link Color} for the ellipse border.
     */
    @Override
    public void handleEllipseBorderColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a change in the ellipse fill color property (ignored by this strategy).
     *
     * @param color The new {@link Color} for the ellipse fill.
     */
    @Override
    public void handleEllipseFillColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a change in the polygon border color property.
     * Updates the internal border color used for new polygons.
     *
     * @param color The new {@link Color} for the polygon border.
     */
    @Override
    public void handlePolygonBorderColorChange(Color color) {
        this.borderColor = color;
    }

    /**
     * Handles a change in the polygon fill color property.
     * Updates the internal fill color used for new polygons.
     *
     * @param color The new {@link Color} for the polygon fill.
     */
    @Override
    public void handlePolygonFillColorChange(Color color) {
        this.fillColor = color;
    }

    /**
     * Handles a change in the text shape's border color property (ignored by this strategy).
     *
     * @param color The new {@link Color} for the text shape's border.
     */
    @Override
    public void handleTextBorderColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a change in the text shape's fill color property (ignored by this strategy).
     *
     * @param color The new {@link Color} for the text shape's fill.
     */
    @Override
    public void handleTextFillColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a change in the text color property (ignored by this strategy).
     *
     * @param color The new {@link Color} for the text.
     */
    @Override
    public void handleTextColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a change in the number of vertices for polygons.
     * Resets the tool's state to start a new polygon drawing with the updated vertex count.
     *
     * @param polygonVertices The new number of vertices.
     */
    @Override
    public void handlePolygonVerticesChange(int polygonVertices) {
        this.polygonVertices = polygonVertices;
        reset(); // Reset tool state to apply new vertex count
    }

    /**
     * Handles a change in the regular polygon property.
     * Resets the tool's state to apply the new mode (regular or irregular).
     *
     * @param regularPolygon A boolean indicating if the polygon should be regular.
     */
    @Override
    public void handleRegularPolygon(boolean regularPolygon) {
        this.regularPolygon = regularPolygon;
        reset(); // Reset tool state to apply new mode
    }

    /**
     * Handles a change in the font size property for text shapes (ignored by this strategy).
     *
     * @param fontSize The new font size.
     */
    @Override
    public void handleFontSizeChange(int fontSize) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a key pressed event (ignored by this strategy).
     *
     * @param event The {@link KeyEvent} generated by the key press.
     */
    @Override
    public void handleKeyPressed(KeyEvent event) {
        // No specific action on key pressed for polygon tool
    }

    /**
     * Handles a key typed event (ignored by this strategy).
     *
     * @param event The {@link KeyEvent} generated by the key typed action.
     */
    @Override
    public void handleKeyTyped(KeyEvent event) {
        // No specific action on key typed for polygon tool
    }

    /**
     * Handles a generic border color change (ignored by this strategy).
     *
     * @param color The new {@link Color} for the border.
     */
    @Override
    public void handleBorderColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a generic fill color change (ignored by this strategy).
     *
     * @param color The new {@link Color} for the fill.
     */
    @Override
    public void handleFillColorChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a text color change from a context menu or global property panel (ignored by this strategy).
     *
     * @param color The new {@link Color} for the text.
     */
    @Override
    public void handleTextColorMenuChange(Color color) {
        // Not applicable for polygon tool
    }

    /**
     * Handles a font size change from a context menu or global property panel (ignored by this strategy).
     *
     * @param fontSize The new font size.
     */
    @Override
    public void handleFontSizeMenuChange(int fontSize) {
        // Not applicable for polygon tool
    }

    /**
     * Returns an empty list of selected shapes, as this tool is for creation, not selection.
     *
     * @return An empty {@code List} of JavaFX {@link Shape} objects.
     */
    @Override
    public List<Shape> getSelectedShapes() {
        return Collections.emptyList();
    }

    /**
     * Resets the tool's internal state, clearing any temporary points, previews, and decorators.
     * This is called to clean up the canvas after a polygon is finalized or cancelled.
     */
    @Override
    public void reset() {
        // Reset for regular polygons
        if (firstPointDecorator != null) {
            firstPointDecorator.removeDecoration();
            firstPointDecorator = null;
        }
        if (firstPointPreview != null) {
            drawingArea.getChildren().remove(firstPointPreview);
            firstPointPreview = null;
        }
        firstPoint = null;
        secondPoint = null;

        // Reset for irregular polygons
        for (ShapeDecorator decorator : previewDecorators) {
            decorator.removeDecoration();
        }
        previewDecorators.clear(); // Clear the list of decorators

        for (Circle circle : vertexPreviews) {
            drawingArea.getChildren().remove(circle);
        }
        vertexPreviews.clear(); // Clear the list of vertex preview circles

        for (Line line : edgePreviews) {
            drawingArea.getChildren().remove(line);
        }
        edgePreviews.clear(); // Clear the list of edge preview lines

        vertices.clear(); // Clear the list of collected vertices
    }

    // Private methods

    /**
     * Handles mouse clicks for drawing regular polygons.
     * On the first click, it sets the starting point. On the second click, it
     * creates the regular polygon if the side length is sufficient, otherwise resets.
     *
     * @param point The {@link Point2D} representing the mouse click location.
     */
    private void handleRegularPolygonClick(Point2D point) {
        if (firstPoint == null) {
            // First point: capture and show preview
            firstPoint = point;
            createFirstPointPreview(point);
        } else {
            // Second point: create regular polygon
            secondPoint = point;
            double sideLength = firstPoint.distance(secondPoint);

            if (sideLength >= MIN_SIDE_LENGTH) {
                Polygon polygon = createRegularPolygon(firstPoint, secondPoint, polygonVertices);
                polygon.setStroke(borderColor);
                polygon.setFill(fillColor);
                polygon.setStrokeWidth(2.0);

                callback.onCreateShape(polygon); // Notify callback for shape creation
                reset(); // Reset tool state
            } else {
                // Side too small, reset
                reset();
            }
        }
    }

    /**
     * Handles mouse clicks for drawing irregular polygons.
     * Adds a new vertex with each click. If the user clicks near the first vertex
     * (and at least 3 vertices exist), the polygon is closed. If the maximum
     * number of vertices is reached, the polygon is automatically closed.
     *
     * @param point The {@link Point2D} representing the mouse click location.
     */
    private void handleIrregularPolygonClick(Point2D point) {
        // Check if the user clicked near the first point to close the polygon (only if at least 3 vertices)
        if (vertices.size() >= 3 && isNearFirstVertex(point)) {
            createIrregularPolygon(); // Close the polygon
            return;
        }

        // Add new vertex if the desired number of vertices has not been reached
        if (vertices.size() < polygonVertices) {
            vertices.add(point);
            createVertexPreview(point);

            // Create edge preview if it's not the first point
            if (vertices.size() > 1) {
                Point2D prevPoint = vertices.get(vertices.size() - 2);
                createEdgePreview(prevPoint, point);
            }

            // If the desired number of vertices is reached, automatically close the polygon
            if (vertices.size() == polygonVertices) {
                createIrregularPolygon();
            }
        }
    }

    /**
     * Creates a small circle preview for the first point of a regular polygon.
     *
     * @param point The {@link Point2D} for the preview circle's center.
     */
    private void createFirstPointPreview(Point2D point) {
        Circle circle = new Circle(point.getX(), point.getY(), POINT_RADIUS);
        circle.setStroke(borderColor);
        circle.setFill(borderColor);
        circle.setStrokeWidth(1.0);

        firstPointPreview = circle;
        firstPointDecorator = new PreviewShapeDecorator(circle);
        firstPointDecorator.applyDecoration(); // Apply preview style

        drawingArea.getChildren().add(circle); // Add to drawing area
    }

    /**
     * Creates a small circle preview for a vertex of an irregular polygon.
     *
     * @param point The {@link Point2D} for the preview circle's center.
     */
    private void createVertexPreview(Point2D point) {
        Circle circle = new Circle(point.getX(), point.getY(), POINT_RADIUS);
        circle.setStroke(borderColor);
        circle.setFill(borderColor);
        circle.setStrokeWidth(1.0);

        ShapeDecorator decorator = new PreviewShapeDecorator(circle);
        decorator.applyDecoration(); // Apply preview style

        vertexPreviews.add(circle);
        previewDecorators.add(decorator);
        drawingArea.getChildren().add(circle);
    }

    /**
     * Creates a line preview for an edge of an irregular polygon.
     *
     * @param start The starting {@link Point2D} of the line.
     * @param end The ending {@link Point2D} of the line.
     */
    private void createEdgePreview(Point2D start, Point2D end) {
        Line line = new Line(start.getX(), start.getY(), end.getX(), end.getY());
        line.setStroke(borderColor);
        line.setStrokeWidth(1.0);

        ShapeDecorator decorator = new PreviewShapeDecorator(line);
        decorator.applyDecoration(); // Apply preview style

        edgePreviews.add(line);
        previewDecorators.add(decorator);
        drawingArea.getChildren().add(line);
    }

    /**
     * Checks if a given point is near the first vertex of the irregular polygon being drawn.
     * This is used to detect when the user intends to close the polygon.
     *
     * @param point The {@link Point2D} to check.
     * @return {@code true} if the point is within a small radius of the first vertex, {@code false} otherwise.
     */
    private boolean isNearFirstVertex(Point2D point) {
        if (vertices.isEmpty()) {
            return false;
        }
        Point2D firstVertex = vertices.get(0);
        return point.distance(firstVertex) <= POINT_RADIUS * 2;
    }

    /**
     * Creates the final irregular polygon using the collected vertices.
     * Notifies the callback for shape creation and then resets the tool.
     */
    private void createIrregularPolygon() {
        if (vertices.size() < 3) {
            return; // Needs at least 3 vertices to form a polygon
        }

        Polygon polygon = new Polygon();
        for (Point2D vertex : vertices) {
            polygon.getPoints().addAll(vertex.getX(), vertex.getY());
        }

        polygon.setStroke(borderColor);
        polygon.setFill(fillColor);
        polygon.setStrokeWidth(2.0);

        callback.onCreateShape(polygon); // Notify callback for shape creation
        reset(); // Reset tool state
    }

    /**
     * Creates a regular polygon based on two points (defining one side) and the number of sides.
     *
     * @param firstPoint The first {@link Point2D} of the first side.
     * @param secondPoint The second {@link Point2D} of the first side.
     * @param sides The number of sides (vertices) for the regular polygon.
     * @return A new {@link Polygon} object representing the regular polygon.
     */
    private Polygon createRegularPolygon(Point2D firstPoint, Point2D secondPoint, int sides) {
        Polygon polygon = new Polygon();

        // The first side is defined by the two clicked points
        polygon.getPoints().addAll(firstPoint.getX(), firstPoint.getY());
        polygon.getPoints().addAll(secondPoint.getX(), secondPoint.getY());

        // Calculate side length
        double sideLength = firstPoint.distance(secondPoint);

        // Calculate the angle of the first side
        double sideAngle = Math.atan2(secondPoint.getY() - firstPoint.getY(),
                secondPoint.getX() - firstPoint.getX());

        // Calculate the interior angle of the regular polygon
        double interiorAngle = Math.PI * (sides - 2) / sides;

        // Generate remaining vertices
        Point2D currentPoint = secondPoint;
        double currentAngle = sideAngle;

        for (int i = 2; i < sides; i++) {
            // Rotate the angle for the next side
            currentAngle += Math.PI - interiorAngle;

            // Calculate the next vertex
            double nextX = currentPoint.getX() + sideLength * Math.cos(currentAngle);
            double nextY = currentPoint.getY() + sideLength * Math.sin(currentAngle);

            currentPoint = new Point2D(nextX, nextY);
            polygon.getPoints().addAll(nextX, nextY);
        }
        return polygon;
    }
}